

  <div id="info">
    <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl skin rendering demo.<br/>
    <a href="http://graphics.cs.williams.edu/data/meshes.xml#14" target="_blank" rel="noopener">Lee Perry-Smith</a> head.
  </div>
         <canvas id="myCanvas"></canvas>



<script>
  var renderer,
    scene,
    camera,
    myCanvas = document.getElementById('myCanvas');
    var statsEnabled = true;

            var directionalLight;
            var mouseX = 0, mouseY = 0;
            var targetX = 0, targetY = 0;
            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;


  //RENDERER
  renderer = new THREE.WebGLRenderer({
    canvas: myCanvas,
    antialias: true
  });
  renderer.setClearColor(0x000000);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  //CAMERA
  camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000 );

  //SCENE
  scene = new THREE.Scene();

  //LIGHTS
  var light = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(light);

  var light2 = new THREE.PointLight(0xffffff, 0.5);
  scene.add(light2);

  var loader = new THREE.GLTFLoader();

  loader.load('<%= asset_path 'romans.glb' %>', handle_load);

  var mesh;
  document.addEventListener( 'mousemove', onDocumentMouseMove, false );
  function handle_load(gltf) {

      console.log(gltf);
      mesh = gltf.scene;
      console.log(mesh.children[0]);
      mesh.children[0].material = new THREE.MeshLambertMaterial();

  scene.add( mesh );
      mesh.position.z = -20;

  }

  function onDocumentMouseMove( event ) {
               windowHalfX = window.innerWidth / 2;
               windowHalfY = window.innerHeight / 2;
               mouseX = ( event.clientX - windowHalfX );
               mouseY = ( event.clientY - windowHalfY + 400);

            }
  //RENDER LOOP
  render();

  var delta = 0;
  var prevTime = Date.now();

  function render() {




         targetX = mouseX * 0.001;
         targetY = mouseY *  0.001;
        if ( mesh ) {

          mesh.rotation.y += 0.05 * ( targetX - mesh.rotation.y );
          mesh.rotation.x += 0.05 * ( targetY - mesh.rotation.x );
          // mesh.rotation.y += 0.01;

          //animation mesh
          // mesh.morphTargetInfluences[ 0 ] = Math.sin(delta) * 20.0;
      }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }


</script>
